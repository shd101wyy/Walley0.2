(define test-hash
  '(:a 12
       :b 13
       :c (lambda (x y) (+ x y))
       )
  )

;; return key list of hash table
(define hash-keys 
  (lambda (hash)
    (cond
     ((eq hash '()) 
      '()
      )
     (1
      (cons 
       (car hash)
       (hash-keys
        (cdr (cdr hash))
        )
       )
      )
     )
    )
  )
;; get value according to key
(define hash-get
  (lambda (x key) 
    (cond
     ((eq x '())
      'undefined
      )
     ((eq (car x) key)
      (ref x 1)
      )
     (1
      (hash-get (cdr (cdr x)) key)
      )
     )
      )
  )

;; set hash key - value
;; ==
(define hash-set
  (lambda (x key value)
    (define hash-set-iter 
      (lambda (x x_copy key value count)
        (cond
         ;; it is empty
         ((eq x '())
          (begin
            (push x_copy key)
            (push x_copy value)
            x_copy
            )
          )
         ;; found existed key
         ((eq (car x) key)
          (set-ref! x 1 value)
          )
         (1
          (hash-set-iter
           (cdr (cdr x)) x_copy key value (+ count 1)
           )
          )
         )
        )
      )
    (hash-set-iter x x key value 0)
      )
  )

;; check x is in y or not
;; (check-in 1 '(1 2 3)) -> true -> 1
(define check-in
  (lambda (x y)
    (cond
     ((eq y '())
      0
      )
     ((eq x (car y)) 1)
     (1
      (check-in x (cdr y))
      )
     )
      )
  )

;; defun macro
;; (defun add (x y) (+ x y)
;; -> (define add (lambda (x y) (+ x y))) 
(define defun (macro (func-name & rest)
                (define params (car rest))
                (define body (cdr rest))
                @(define ,func-name (lambda ,params 
                                      ,body
                                      )
                   )
                )
  )

;; if judge stm1 stm2
(define if (macro (& params)
             (define judge (ref params 0))
             (cond
              (judge
               (ref params 1)
               )
              (1
               (ref params 2)
               )
              )
             ))

;; situation 1
;; (range-1 4) -> (0 1 2 3)
(define range-1 
  (lambda (x)
    (define i 0)
    (define output '())
    (while (< i x)
           (push output i)
           (set! i (+ i 1))
           )
    output
    )
  )

;; situation 2
;; (range-2 3 5) -> (3 4)
(define range-2 
  (lambda (x y)
    (define i x)
    (define output '())
    (while (< i y)
           (push output i)
           (set! i (+ i 1))
           )
    output
    )
  )

;; situation 3
;; (range 5 10 2) -> (5 7 9)
(define range-3 
  (lambda (x y interval)
    (define i x)
    (define output '())
    (cond 
     ((<= interval 0)
      (while (> i y)
             (push output i)
             (set! i (+ i interval))
       )
      )
     (1
      (while (< i y)
             (push output i)
             (set! i (+ i interval))
             )
      )
     )
    output
    )
  )
;; python like range
;; (range 10) -> (0 1 2 3 4 5 6 7 8 9) from 0 to 10 interval 1
;; (range 5 10) -> (5 6 7 8 9) from 5 to 10 interval 1
;; (range 5 10 2) -> (5 7 9) from 5 to 10 interval 2
(define range 
  (lambda (& params)
    (cond
     ;; situation 1
     ((eq (len params) 1)
      (apply range-1 params)
      )
     ;; situation 2
     ((eq (len params) 2)
      (apply range-2 params)
      )
     (1
      (apply range-3 params)
      )
     )
    )  
  )

(define null? 
  (lambda (x)
    (cond
     ((eq x '()) 1)
     (1 0)
     )
    )
  )
(define empty? null?)

;; (1 2) (3 4) -> (1 2 3 4)
(define append 
  (lambda (x y)
    (cond
     ((null? x) y)
     (1 (cons (car x) (append (cdr x) y)))
     )
    )
  )

;; function dolist
;; (dolist var_name list body)

(define dolist
  (macro (& params)
    (let
        (
         (var-name (car params))
         (iter-list (ref params 1) )
         (body (slice params 2 (len params)))
         
        )
      
      (append @(for ,var-name in ,iter-list) body)
     ;; @(for ,var-name in ,iter-list ,body)

      )
    )
  )

(define list 
  (lambda (. args)
    args
    )
  )

;; (1 2) + (3 4) -> (4 6) 
(define list-add
  (lambda (x y)
    (define list-add-iter
      (lambda (x y result)
        (cond
         ((or (null? x) (null? y))
          result
          )
         (1 
            (list-add-iter (cdr x) (cdr y) (push result (apply + (list (car x) (car y)))))
          )
         )
        )
      )
    (list-add-iter x y '())
    )
  )

(define factorial 
  (lambda (n)
    (define factorial-iter
      (lambda (n result)
        (cond
         ((eq n 1) result)
         (1 (factorial-iter (- n 1) (* result n) ))
         )
        )
      )
    (factorial-iter n 1)
    )
  )

(define add (lambda (a b) (+ a b)))
(display (add 3 4))
;; (display (null? '()))
(display (list-add '(1 5) '(2 3)))
;; (display (or (null? '()) (null? '(123)) ))
;; (display (factorial 4))
