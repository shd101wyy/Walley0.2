(begin
	;==============================================
	;==============================================
	;==============================================
	;===== Begin to construct Toy Language ========
	;==============================================

	(define cadr (lambda (_list_)
		(car (cdr _list_))
		))
	(define caar (lambda (_list_)
		(car (car _list_))
		))
	(define cdar (lambda (_list_)
		(cdr (car _list_))
		))
	(define cadar (lambda (_list_)
		(car (cdr (car _list_)))
		))
	(define caddr (lambda (_list_)
		(car (cdr (cdr _list_)))
		))
	(define caddar (lambda (_list_)
		(car (cdr (cdr (car _list_))))
		))

	; '(a b) '(c d) -> (a b c d)
	(define append (lambda (x y)
		(cond 
			((null? x) y)
			(1 (cons (car x) (append (cdr x) y)))
			)
		))
	; '(a b) '(3 4) -> ((a 3) (b 4))
	(define pair (lambda (x y)
		(cond
			((and (null? x) (null? y) )  '() )
			(1 (cons (cons (car x) (cons (car y) '())) (pair (cdr x) (cdr y))))
			)
		))
	; get value according to key
	; (assoc 'x '((x  a) (y  b) )) -> a
	(define assoc (lambda (x y)
		(cond 
			((null? y) 
				(begin 
					(display "Error_Cannot_Find")
					(display x)
					'Error_Cannot_Find
					)
				)
			((eq (caar y) x) (cadar y))
			(1 (assoc x (cdr y)) )
			)
		))

	; Toy Language
	; (toy 'x  '((x . a)) ) -> x
	; expr is the expression that need to be evaluated
	; env is the environment
	(define toy (lambda (expr env)
		(print env)
		(print "\n")
		(cond
			((number? expr) expr)
			((atom? expr) (assoc expr env) )
			((atom? (car expr))
				(cond
					; seven primitive functions
					; (quote x) -> x
					((eq (car expr) 'quote) (cadr expr))
					; (atom? 'x) -> 1
					((eq (car expr) 'atom?) (atom? (toy (cadr expr) env)))
					; (eq 'x 'x) -> 1
					((eq (car expr) 'eq)  
						(eq (toy (car (cdr expr)) env )
							(toy (car (cdr (cdr expr))) env)
							)
						)
					; (car '(a b))->a
					((eq (car expr) 'car) (car (toy (cadr expr) env)) )
					; (cdr '(a b)) -> (b)
					((eq (car expr) 'cdr) (cdr (toy (cadr expr) env)) )
					; (cons 'a '(a) ) -> (a a)
					((eq (car expr) 'cons)
						(cons (toy (car (cdr expr)) env)
							  (toy (car (cdr (cdr expr))) env)
							)
						)
					; (cond (judge1 stm1) (judge2 stm2) ) 
					((eq (car expr) 'cond) (eval_cond (cdr expr) env))

					; builtin functions
					((eq (car expr) '__ADD__)	
						(apply __ADD__ (evlis (cdr expr) env))	
						)
					((eq (car expr) '__MINUS__)	
						(apply __MINUS__ (evlis (cdr expr) env))	
						)
					((eq (car expr) '__MULT__)	
						(apply __MULT__ (evlis (cdr expr) env))	
						)
					((eq (car expr) '__DIV__)	
						(apply __DIV__ (evlis (cdr expr) env))	
						)
					((eq (car expr) '__LT__)
						(apply __LT__ (evlis (cdr expr) env))
						)
					((eq (car expr) '__EQUAL__)
						(apply __EQUAL__ (evlis (cdr expr) env))
						)
					;=== my idea ====
					((eq (car expr) 'lambda)
						expr
						)
					; (begin stm1 stm2)
					((eq (car expr) 'begin)
						(eval_begin (cdr expr) env)
						)
					; (let ((var value) (var value) ... ) stm )
					((eq (car expr) 'let)
						(toy (caddr expr) (eval_let (cadr expr) env))
						)
					; (procesdure argv...)
					(1 
						(toy (cons (assoc (car expr) env) (cdr expr)) env)
						)
					)
				)
			; label function
			((eq (caar expr) 'label)
				(toy (cons (caddar expr) (cdr expr))
					(cons (list (cadar expr) (car expr)) env )
					)
				)
			; lambda function
			((eq (caar expr) 'lambda)
				(toy (caddar expr)
					(append (pair (cadar expr) (evlis (cdr expr) env)) env)
					)
				)
			)
		))

	; return new env
	; expr -> ((a 12)(b 13)) 
	; env -> ((c 14))
	; return ((a 12)(b 13)(c 14))
	(define eval_let (lambda (expr env)
		(cond 
			((eq expr '()) env)
			(1 
				(cons    
					(cons (caar expr) (cons (toy (cadar expr) env) '()))
					(eval_let (cdr expr) env))
				)
			)
		))

	; eval cond function
	(define eval_cond (lambda (expr env)
		(cond 
			((toy (caar expr) env) 
			 (toy (cadar expr) env)
				)
			(1 (eval_cond (cdr expr) env))
			)
		))

	; compute function params
	(define evlis (lambda (m a)
		(cond 
			((null? m) '())
			(1 (cons (toy (car m) a) (evlis (cdr m) a)))
			)
		))
	; eval begin function
	; stms -> (stm1 stm2 stm3)
	(define eval_begin (lambda (stms env)
		(cond 
			((null? stms)(display "Error...begin function invalid parameters"))
			((null? (cdr stms))  (toy (car stms) env))
			(1
				(cond 
					; it is atom
					; so not calculated
					((atom? (car stms)) (eval_begin (cdr stms) env))
					(1
						(cond
							; define
							; (define x 12)
							; (define y 13) ... something like that
							((eq (caar stms) 'define)
								(eval_begin (cdr stms) (cons (cons (cadar stms) (cons (toy (caddar stms) env) '())) env))
								)
							; change existed value
							((eq (caar stms) 'set!)
								(eval_begin (cdr stms) (set!_env (cadar stms) (toy (caddar stms) env) env) )
								)
							)
						)
					)
				)
			; define can only be used inside begin
			)
		))

	; var_name -> x
	; var_value -> 12
	; env -> ((y 12) (x 1))
	; return ((y 12) (x 12))
	(define set!_env (lambda (var_name var_value env)
		(cond
			((null? env) "Error...set!_env function error")
			((eq (caar env) var_name)
				(cons (cons var_name (cons var_value '()))  (cdr env))
				)
			(1 
				(cons (car env) (set!_env var_name var_value (cdr env)))
				)
			)
		))

	(display (toy '(hi 123) '((x . a))))














)
