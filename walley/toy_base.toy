(begin
	;==============================================
	;==============================================
	;==============================================
	;===== Begin to construct Toy Language ========
	;==============================================
	;
	;
	;
	;	 I will only write this in 
	;	'quote car cdr cons cond eq atom' 
	;	====
	;   and one 'define' function
	(define cadr (lambda (_list_)
		(car (cdr _list_))
		))
	(define caar (lambda (_list_)
		(car (car _list_))
		))
	(define cdar (lambda (_list_)
		(cdr (car _list_))
		))
	(define cadar (lambda (_list_)
		(car (cdr (car _list_)))
		))
	(define caddr (lambda (_list_)
		(car (cdr (cdr _list_)))
		))
	(define caddar (lambda (_list_)
		(car (cdr (cdr (car _list_))))
		))

	(define null? (lambda (x)
		(eq x '())
		))
	; '(a b) '(c d) -> (a b c d)
	(define append (lambda (x y)
		(cond 
			((null? x) y)
			(1 (cons (car x) (append (cdr x) y)))
			)
		))
	; '(a b) '(3 4) -> ((a 3) (b 4))
	(define pair (lambda (x y)
		(cond
			((and (null? x) (null? y) )  '() )
			(1 (cons (cons (car x) (cons (car y) '())) (pair (cdr x) (cdr y))))
			)
		))
	; get value according to key
	; (assoc 'x '((x  a) (y  b) )) -> a
	(define assoc (lambda (x y)
		(cond 
			; Error can not find value
			((null? y) 
					(display 'Error_Cannot_Find)
				)
			((eq (caar y) x) (cadar y))
			(1 (assoc x (cdr y)) )
			)
		))

	; Toy Language iteration
	(define toy_language (lambda (trees env module_name)
		(cond
			; finish toy_language
			((null? trees) env)
			; iteration
			(1
				(toy_language 
					; next tree
					(cdr trees)
					; update environment
					(cdar (toy (car trees) env module_name))
					; module_name
					module_name)
				)
			)
		))

	; [value , env]
	(define cons_env (lambda (value env)
		(cons value (cons env '()))
		))

	; =========================
	; for define function
	;check whether var existed
	(define var_existed(lambda (var_name env)
		(cond 
			((null? env) 0)
			((eq var_name (caar env)) 1)
			(1 (var_existed var_name (cdr env)))
			)
		))
	; update var_name
	; add module_name
	(define var_name_update (lambda (var_name module_name)
		(cond 
			((eq module_name "") var_name)
			(1 (cons (module_name '.) var_name))
			)
		))
	; deal with return object
	; where return object is toy
	; return_obj[0] = var_value
	; return_obj[1] = new_env

	(define deal_with_return_obj (lambda (return_obj var_name)
		(cons 
			; add var_value
			(car return_obj)
		(cons 
		(cons 
			; [var_name var_value]
			(cons var_name (cons (car return_obj) '()))
			(cadr return_obj)
			)  '())
			)
		))

	;define function procedure
	(define define_procedure (lambda (updated_var_name uncalculated_var_value env module_name)
		(cond 
			((var_existed updated_var_name env)
				(display (cons (cons "Error " updated_var_name) " Has already be defined") )
				)
			(1 (deal_with_return_obj (toy uncalculated_var_value env module_name) updated_var_name))
			)
		))

	;=================== END define function procedure ==========
	;============================================================

	;========= set! function procedure ==========

	; return new environment
	(define set_index (lambda (var_name var_value env)
		(cond
			((null? env) 
				((lambda (a b) b) 
					(display (cons (cons "Error...In function set! " var_name) " does not exist")) '()
					)
				)
			; find var
			((eq var_name (caar env))
				(cons 
					; (var_name var_value)
					(cons 
						var_name
						(cons var_value '())
						)
					; rest of env
					(cdr env))
				)
			(1 (cons (car env) (set_index var_name var_value (cdr env))))
			)
		))

	(define set!_procedure (lambda (var_name return_obj)
		;(var_value new_env)
		(cons (car return_obj) (cons (set_index var_name (car return_obj) (cadr return_obj)) '()))
		))


	;========= End set! function procedure ======

	;========= let function procedure ===========
	;============================================
	;return new env
	;expr -> ((a 12)(b 13)) 
	;env -> ((c 14))
	;return ((a 12)(b 13)(c 14))
	(define eval_let (lambda (expr env module_name)
		(cond 
			((null? expr)
				env)
			; now ((x 12)(y x)) -> y = 12
			(1 
				(eval_let (cdr expr) 
					(cons 
					; (var_name var_value)
						; var_name
						(cons (caar expr)
						(cons 
						; var_value... this place has problem.. env maybe updated
						(car (toy (cadar expr) env module_name)) '())
						)
						env
					)
					module_name				
					)
				)
			)
		))
	; restore new_env to old_env length
	(define restore_env (lambda (old_env new_env new_env_copy)
		(cond 
			((null? old_env)
				(cond 
					((null? new_env) new_env_copy)
					(1 (restore_env old_env (cdr new_env) (cdr new_env_copy)))
					)
				)
			(1 (restore_env (cdr old_env) (cdr new_env) new_env_copy))
			)
		))
	(define let_procedure (lambda (return_obj env)
		(cons 
			(car return_obj)
			(cons
				(restore_env env (cadr return_obj) (cadr return_obj))
				'()
				)
			)
		))
	;=================== END let function procedure =============
	;============================================================

	;====== function begin ======
	;============================
	(define eval_begin (lambda (expr env module_name)
		(cond 
			((null? expr) (display "Error...begin function params num error"))
			((null? (cdr expr))
				(toy (car expr) env module_name)
				)
			(1 (eval_begin (cdr expr) (cadr (toy (car expr) env module_name)) module_name))
			)
		))

	;============================

	;======= procedure ==========
	;(toy (cons (assoc (car expr) env) (cdr expr)) env)
	; eg: (add 3 4)-> (+ 3 4) replace add with +
	(define procedure_procedure (lambda (func_name params env module_name)
		(cond 
			; error... cannot deal with that procedure
			((null? env) 
				(display (cons "Undefined Function " func_name))
				)
			; find assoc function
			((eq func_name (car (car env)))
				(toy (cons (cadar env) params) env module_name)
				)
			; iteration
			(1 (procedure_procedure func_name params (cdr env) module_name))
			)
		))
	;============================
	;======== function lambda ===
	; compute function params
	; ["x","y"] [["x",12],["y",13]] -> [12,13]
	(define evlis (lambda (params env module_name)
		(cond 
			((null? params) '())
			(cons (car (toy (car params) env module_name)) (evlis (cdr params env module_name)))
			)
		))

	; pair_params
	; ["a","b"] ["1","2"] -> [["a","1"],["b","2"]]
    ; [". args"] ["1","2"] -> [["args", ["1","2"]]] 
    (define pair_params (lambda (names params env module_name)
    	(cond 
    		((null? names) '())
    		; calculate params
    		;==
    		;variadic params
    		((eq (car names) '.)
    			(cons 
				(cons 
					(cadr names)
					(cons 
					(evlis params env module_name)
					'())
					)
				'())
				)
    		; lazy evaluation->does not calculate params
    		((eq (car names) '&)
    			(cons 
    			(cons 
    				(cadr names)
    				(cons 
    				params
    				'())
    				)
    			'())
    			)
    		(1 	
    			(cons 
    				;calcuate param
    				(cons 
    					;参数名字 
    					(car names)
    					(cons 
    						;得到计算好的参数的数值
    						(car (toy (car params) env module_name))
    						'()
    						)
    					)
    				
    				(pair_params (cdr names) (cdr params) env module_name)
    				)
    			)
    		)
    	))

        ;return[return_value, return_env[len(return_env)-len(env):len(return_env)]]
    	(define deal_with_return_obj_for_lambda_procedure (lambda (return_value return_env env)
    		(cons 
    			return_value
    			(cons 
    				(restore_env env return_env return_env)
    				'())
    			)
    		))
    	; return_obj -> toy(tree[0][2], append(pair_params(tree[0][1],cdr(tree),env),env))
    	(define lambda_procedure (lambda (return_obj env module_name)
    		(deal_with_return_obj_for_lambda_procedure (car return_obj) (cadr return_obj) env)
    		))

                ;def pair_params(names,params,env):
                ;    if names==[]:
                ;        return []
                ;    # calculate params
                ;    elif names[0]==".":
                ;        return [[names[1],evlis(params,env)]]
                ;    # lazy and does not calculate params
                ;    elif names[0]=="&":
                ;        return [[names[1],params]]
                ;    else:
                ;        return cons([names[0],toy(params[0],env)[0]],pair_params(names[1:len(names)],params[1:len(params)],env))


	;============================

	; Toy Language
	; (toy 'x  '((x . a)) ) -> x
	; expr is the expression that need to be evaluated
	; env is the environment
	(define toy (lambda (expr env module_name)
		(cond
			; it is number
			((number? expr) (cons_env expr env))
			; it is atom
			;				[value,env]
			((atom? expr) (cons (assoc expr env) (cons env '())) )
			((atom? (car expr))
				(cond
					; seven primitive functions
					; (quote x) -> x
					;						 [value,env]
					((eq (car expr) 'quote) (cons (cadr expr) (cons env '()) ))
					; (atom? 'x) -> 1
					((eq (car expr) 'atom?) 
						(cons_env (atom? (car (toy (cadr expr) env module_name))) env)
						)
					; (eq 'x 'x) -> 1
					((eq (car expr) 'eq)  
						(cons_env
							(eq 
								(car (toy (cadr expr) env module_name))
								(car (toy (caddr expr) env module_name))
								)
							env
						)
						)
					; (car '(a b))->a
					((eq (car expr) 'car) 
						(cons_env 
							(car (car (toy (cadr expr) env module_name)))
							env
						)

						)
					; (cdr '(a b)) -> (b)
					((eq (car expr) 'cdr) 
						(cons_env
							(cdr (car (toy (cadr expr) env module_name) ) )
							env
							)
						)
					; (cons 'a '(a) ) -> (a a)
					((eq (car expr) 'cons)
						(cons_env
							(cons 
								(car (toy (car (cdr expr)) env module_name))
								(car (toy (car (cdr (cdr expr))) env module_name))
								)
							env
							)
						)
					; (cond (judge1 stm1) (judge2 stm2) ) 
					((eq (car expr) 'cond) (eval_cond (cdr expr) env module_name))

					; builtin functions
					; define function
					((eq (car expr) 'define)
						(define_procedure 
							(var_name_update (cadr expr) module_name)
							(caddr expr)
							env 
							module_name
							)
						)
					; set! function
					((eq (car expr) 'set!) 
						(set!_procedure
							(cadr expr)
							(toy (caddr expr) env module_name)
							)
						)
					;=== my idea ====
					((eq (car expr) 'lambda)
						(cons_env expr env)
						)
					; (begin stm1 stm2)
					((eq (car expr) 'begin)
						(eval_begin (cdr expr) env module_name)
						)
					; (let ((var value) (var value) ... ) stm )
					((eq (car expr) 'let)
						(let_procedure (toy (caddr expr) (eval_let (cadr expr) env module_name) module_name) env)
						)
					; (procesdure argv...)
					(1 
						(procedure_procedure (car expr) (cdr expr) env module_name)
						)
					)
				)
			; label function
			; well... I don not want to support label function
			;((eq (caar expr) 'label)
			;	(toy (cons (caddar expr) (cdr expr))
			;		(cons (list (cadar expr) (car expr)) env )
			;		)
			;	)
			; lambda function
			((eq (caar expr) 'lambda)
				;return_obj -> toy(tree[0][2], append(pair_params(tree[0][1],cdr(tree),env),env))
    			;(define lambda_procedure (lambda (return_obj env module_name)
    			(lambda_procedure  
    				(toy (caddr (car expr)) (append (pair_params (cadr (car expr)) (cdr expr) env module_name) env) module_name)
    				env 
    				module_name)
    			)
			)
		))


	; eval cond function
	(define eval_cond (lambda (expr env module_name)
		(cond 
			((car (toy (caar expr) env module_name))
			 (toy (cadar expr) env module_name)
				)
			(1 (eval_cond (cdr expr) env module_name))
			)
		))

	



	(display (assoc 'a '((a (a b c)))))
	(display (toy '(a '(1 2 3)) '((a (lambda (a) (cdr a))) (b (a b c))) ""))
)













