(begin
	;==============================================
	;==============================================
	;==============================================
	;===== Begin to construct Toy Language ========
	;==============================================
	;
	;
	;
	;	 I will only write this in 
	;	'quote car cdr cons cond eq atom' 
	;	====
	;   and one 'define' function
	(define cadr (lambda (_list_)
		(car (cdr _list_))
		))
	(define caar (lambda (_list_)
		(car (car _list_))
		))
	(define cdar (lambda (_list_)
		(cdr (car _list_))
		))
	(define cadar (lambda (_list_)
		(car (cdr (car _list_)))
		))
	(define caddr (lambda (_list_)
		(car (cdr (cdr _list_)))
		))
	(define caddar (lambda (_list_)
		(car (cdr (cdr (car _list_))))
		))

	(define null? (lambda (x)
		(eq x '())
		))
	; '(a b) '(c d) -> (a b c d)
	(define append (lambda (x y)
		(cond 
			((null? x) y)
			(1 (cons (car x) (append (cdr x) y)))
			)
		))
	; '(a b) '(3 4) -> ((a 3) (b 4))
	(define pair (lambda (x y)
		(cond
			((and (null? x) (null? y) )  '() )
			(1 (cons (cons (car x) (cons (car y) '())) (pair (cdr x) (cdr y))))
			)
		))
	; get value according to key
	; (assoc 'x '((x  a) (y  b) )) -> a
	(define assoc (lambda (x y)
		(cond 
			; Error can not find value
			((null? y) 
					(display 'Error_Cannot_Find)
				)
			((eq (caar y) x) (cadar y))
			(1 (assoc x (cdr y)) )
			)
		))

	; Toy Language iteration
	(define toy_language (lambda (trees env module_name)
		(cond
			; finish toy_language
			((null? trees) env)
			; iteration
			(1
				(toy_language 
					; next tree
					(cdr trees)
					; update environment
					(cdar (toy (car trees) env module_name))
					; module_name
					module_name)
				)
			)
		))

	; [value , env]
	(define cons_env (lambda (value env)
		(cons value (cons env '()))
		))

	; =========================
	; for define function
	;check whether var existed
	(define var_existed(lambda (var_name env)
		(cond 
			((null? env) 0)
			((eq var_name (caar env)) 1)
			(1 (var_existed var_name (cdr env)))
			)
		))
	; update var_name
	; add module_name
	(define var_name_update (lambda (var_name module_name)
		(cond 
			((eq module_name "") var_name)
			(1 (cons (module_name '.) var_name))
			)
		))
	; deal with return object
	; where return object is toy
	; return_obj[0] = var_value
	; return_obj[1] = new_env

	(define deal_with_return_obj (lambda (return_obj var_name)
		(cons 
			; add var_value
			(car return_obj)
		(cons 
		(cons 
			; [var_name var_value]
			(cons var_name (cons (car return_obj) '()))
			(cadr return_obj)
			)  '())
			)
		))

	;define function procedure
	(define define_procedure (lambda (updated_var_name uncalculated_var_value env module_name)
		(cond 
			((var_existed updated_var_name env)
				(display (cons (cons "Error " updated_var_name) " Has already be defined") )
				)
			(1 (deal_with_return_obj (toy uncalculated_var_value env module_name) updated_var_name))
			)
		))

	;=================== END define function procedure ==========
	;============================================================

	;========= set! function procedure ==========

	; return new environment
	(define set_index (lambda (var_name var_value env)
		(cond
			((null? env) 
				((lambda (a b) b) 
					(display (cons (cons "Error...In function set! " var_name) " does not exist")) '()
					)
				)
			; find var
			((eq var_name (caar env))
				(cons 
					; (var_name var_value)
					(cons 
						var_name
						(cons var_value '())
						)
					; rest of env
					(cdr env))
				)
			(1 (cons (car env) (set_index var_name var_value (cdr env))))
			)
		))

	(define set!_procedure (lambda (var_name return_obj)
		;(var_value new_env)
		(cons (car return_obj) (cons (set_index var_name (car return_obj) (cadr return_obj)) '()))
		))


	;========= End set! function procedure ======

	;========= let function procedure ===========
	;============================================
	;return new env
	;expr -> ((a 12)(b 13)) 
	;env -> ((c 14))
	;return ((a 12)(b 13)(c 14))
	(define eval_let (lambda (expr env module_name)
		(cond 
			((null? expr)
				env)
			; now ((x 12)(y x)) -> y = 12
			(1 
				(eval_let (cdr expr) 
					(cons 
					; (var_name var_value)
						; var_name
						(cons (caar expr)
						(cons 
						; var_value... this place has problem.. env maybe updated
						(car (toy (cadar expr) env module_name)) '())
						)
						env
					)
					module_name				
					)
				)
			)
		))
	; restore new_env to old_env length
	(define restore_env (lambda (old_env new_env new_env_copy)
		(cond 
			((null? old_env)
				(cond 
					((null? new_env) new_env_copy)
					(1 (restore_env old_env (cdr new_env) (cdr new_env_copy)))
					)
				)
			(1 (restore_env (cdr old_env) (cdr new_env) new_env_copy))
			)
		))
	(define let_procedure (lambda (return_obj env)
		(cons 
			(car return_obj)
			(cons
				(restore_env env (cadr return_obj) (cadr return_obj))
				'()
				)
			)
		))
	;=================== END let function procedure =============
	;============================================================

	;====== function begin ======
	;============================
	(define eval_begin (lambda (expr env module_name)
		(cond 
			((null? expr) (display "Error...begin function params num error"))
			((null? (cdr expr))
				(toy (car expr) env module_name)
				)
			(1 (eval_begin (cdr expr) (cadr (toy (car expr) env module_name)) module_name))
			)
		))

	;============================

	;======= procedure ==========
	;(toy (cons (assoc (car expr) env) (cdr expr)) env)
	; eg: (add 3 4)-> (+ 3 4) replace add with +
	(define procedure_procedure (lambda (func_name params env module_name)
		(cond 
			; error... cannot deal with that procedure
			((null? env) 
				(display (cons "Undefined Function " func_name))
				)
			; find assoc function
			((eq func_name (car (car env)))
				(toy (cons (cadar env) params) env module_name)
				)
			; iteration
			(1 (procedure_procedure func_name params (cdr env) module_name))
			)
		))
	;============================
	;======== function lambda ===
	; compute function params
	; ["x","y"] [["x",12],["y",13]] -> [12,13]
	(define evlis (lambda (params env module_name)
		(cond 
			((null? params) '())
			(1 (cons (car (toy (car params) env module_name)) (evlis (cdr params) env module_name)))
			)
		))

	; pair_params
	; ["a","b"] ["1","2"] -> [["a","1"],["b","2"]]
    ; [". args"] ["1","2"] -> [["args", ["1","2"]]] 
    (define pair_params (lambda (names params env module_name)
    	(cond 
    		((null? names) '())
    		; calculate params
    		;==
    		;variadic params
    		((eq (car names) '.)
    			(cons 
				(cons 
					(cadr names)
					(cons 
						(evlis params env module_name)
						'())
					)
				'())
				)
    		; lazy evaluation->does not calculate params
    		((eq (car names) '&)
    			(cons 
    			(cons 
    				(cadr names)
    				(cons 
    				params
    				'())
    				)
    			'())
    			)
    		(1 	
    			(cons 
    				;calcuate param
    				(cons 
    					;参数名字 
    					(car names)
    					(cons 
    						;得到计算好的参数的数值
    						(car (toy (car params) env module_name))
    						'()
    						)
    					)
    				
    				(pair_params (cdr names) (cdr params) env module_name)
    				)
    			)
    		)
    	))

        ;return[return_value, return_env[len(return_env)-len(env):len(return_env)]]
    	(define deal_with_return_obj_for_lambda_procedure (lambda (return_value return_env env)
    		(cons 
    			return_value
    			(cons 
    				(restore_env env return_env return_env)
    				'())
    			)
    		))
    	; return_obj -> toy(tree[0][2], append(pair_params(tree[0][1],cdr(tree),env),env))
    	(define lambda_procedure (lambda (return_obj env module_name)
    		(deal_with_return_obj_for_lambda_procedure (car return_obj) (cadr return_obj) env)
    		))

                
        ;==============
    	; eval cond function
		(define eval_cond (lambda (expr env module_name)
			(cond 
				((car (toy (caar expr) env module_name))
				 (toy (cadar expr) env module_name)
					)
				(1 (eval_cond (cdr expr) env module_name))
				)
			))
		;==============

	;============================

	; Toy Language
	; (toy 'x  '((x . a)) ) -> x
	; expr is the expression that need to be evaluated
	; env is the environment
	(define toy (lambda (expr env module_name)
		(cond
			; it is number
			((number? expr) (cons_env expr env))
			; it is atom
			;				[value,env]
			((atom? expr) (cons (assoc expr env) (cons env '())) )
			((atom? (car expr))
				(cond
					; seven primitive functions
					; (quote x) -> x
					;						 [value,env]
					((eq (car expr) 'quote) (cons (cadr expr) (cons env '()) ))
					; (atom? 'x) -> 1
					((eq (car expr) 'atom?) 
						(cons_env (atom? (car (toy (cadr expr) env module_name))) env)
						)
					; (eq 'x 'x) -> 1
					((eq (car expr) 'eq)  
						(cons_env
							(eq 
								(car (toy (cadr expr) env module_name))
								(car (toy (caddr expr) env module_name))
								)
							env
						)
						)
					; (car '(a b))->a
					((eq (car expr) 'car) 
						(cons_env 
							(car (car (toy (cadr expr) env module_name)))
							env
						)

						)
					; (cdr '(a b)) -> (b)
					((eq (car expr) 'cdr) 
						(cons_env
							(cdr (car (toy (cadr expr) env module_name) ) )
							env
							)
						)
					; (cons 'a '(a) ) -> (a a)
					((eq (car expr) 'cons)
						(cons_env
							(cons 
								(car (toy (car (cdr expr)) env module_name))
								(car (toy (car (cdr (cdr expr))) env module_name))
								)
							env
							)
						)
					; (cond (judge1 stm1) (judge2 stm2) ) 
					((eq (car expr) 'cond) (eval_cond (cdr expr) env module_name))

					; builtin functions
					; define function
					((eq (car expr) 'define)
						(define_procedure 
							(var_name_update (cadr expr) module_name)
							(caddr expr)
							env 
							module_name
							)
						)
					; set! function
					((eq (car expr) 'set!) 
						(set!_procedure
							(cadr expr)
							(toy (caddr expr) env module_name)
							)
						)
					;=== my idea ====
					((eq (car expr) 'lambda)
						(cons_env expr env)
						)
					; (begin stm1 stm2)
					((eq (car expr) 'begin)
						(eval_begin (cdr expr) env module_name)
						)
					; (let ((var value) (var value) ... ) stm )
					((eq (car expr) 'let)
						(let_procedure (toy (caddr expr) (eval_let (cadr expr) env module_name) module_name) env)
						)
					; (apply func_name '(params ...))
					((eq (car expr) 'apply)
						(toy (cons (cadr expr) (cdr (cdr expr))) env module_name)
						)
					((eq (car expr) 'eval)
						(toy (car (toy (cadr expr) env module_name)) env module_name)
						)
					; (procesdure argv...)
					(1 
						(procedure_procedure (car expr) (cdr expr) env module_name)
						)
					)
				)
			; label function
			; well... I don not want to support label function
			;((eq (caar expr) 'label)
			;	(toy (cons (caddar expr) (cdr expr))
			;		(cons (list (cadar expr) (car expr)) env )
			;		)
			;	)
			; lambda function
			((eq (caar expr) 'lambda)
				;return_obj -> toy(tree[0][2], append(pair_params(tree[0][1],cdr(tree),env),env))
    			;(define lambda_procedure (lambda (return_obj env module_name)
    			(lambda_procedure  
    				(toy (caddr (car expr)) (append (pair_params (cadr (car expr)) (cdr expr) env module_name) env) module_name)
    				env 
    				module_name)
    			)
			)
		))



; =========== implement + - * / ========================
; === for real number and fraction only
;
;
; ====format number funtion
; 12 -> (  12     1  )
;        numerator   denominator
;
; 12.04 -> ( 12.04 1 )
; 13.04/5 -> (13.04 5)
; 

	; remainder function
	(define remainder (lambda (a b) 
		(cond 
			((__LT__ a b) a)
			('1 (remainder (- a b) b))
			)	
		))

	; GCD
	; General Common Divisor
	(define gcd (lambda (a b)
		(cond 
			((__EQUAL__ b 0) a)
			('1 (gcd b (remainder a b)))
			)
  		))

	; fraction arithematic
	(define add-rat (lambda (x y) 
		(make-rat 
			(+ 
				(* (numer x) (denom y))  
				(* (numer y) (denom x))
			)
			(* (denom x) (denom y)) )
		))
	(define sub-rat (lambda (x y) 
		(make-rat
			(- 
				(* (numer x) (denom y))  
				(* (numer y) (denom x))
			)
			(* (denom x) (denom y)) )
		))

	; (a/b)*(c/d) = (a*c) / (b*d)
	(define mul-rat (lambda (x y) 
		(make-rat
			(* (numer x) (numer y)) 
			(* (denom x) (denom y)) 
			)
		))
	; (a/b)/(c/d) -> (a*d)/(b*c)
	(define div-rat (lambda (x y)
		(make-rat
			(* (numer x) (denom y))
			(* (denom x) (numer y))
			)
		))
	; a/b c/d
	(define equal-rat? (lambda (x y)
		(= 
			(* (numer x) (denom y))
			(* (denom x) (numer y))
			)
		))
	(define removeDot_iter (lambda (num)
		(cond 
			((null? num) "")
			((eq (car num) '.) "")
			('1 (cons (car num) (removeDot_iter (cdr num)) ))
			)
		))
	; 12.000 -> 12
	; 12.4500 -> 12
	(define removeDot (lambda (num)
		(removeDot_iter num)
		))
	(define 约分函数根据gcd (lambda (n d g)
		(cons (removeDot (/ n g)) (cons (removeDot (/ d g)) '()) )
		))
	(define make-rat (lambda (n d) 
		(约分函数根据gcd n d (gcd n d))
		))
	(define numer (lambda (x) (car x)))
	(define denom (lambda (x) (cadr x)))
	(define make_rat_string (lambda (rat)
		(cons (car rat) (cons '/ (cadr rat)))
		))


	;============ format number ====================
	(define get_numerator (lambda (num)
		(cond
			((null? num) "")
			((eq (car num) '/) "")
			(1 (cons (car num) (get_numerator (cdr num))))
			)
		))
	(define get_denominator (lambda (num)
		(cond 
			((null? num) '1)
			((eq (car num) '/) (cdr num))
			(1 (get_denominator (cdr num)))
			)
		))

	(define format_number (lambda (num)
		(cons (get_numerator num) (cons (get_denominator num) '()))
		))
	; check whether one char is digit
	(define 这个数字是整数 (lambda (value)
		(cond
			((eq value '0) 1) 
			((eq value '1) 1)
			((eq value '2) 1)
			((eq value '3) 1)
			((eq value '4) 1)
			((eq value '5) 1)
			((eq value '6) 1)
			((eq value '7) 1)
			((eq value '8) 1)
			((eq value '9) 1)
			(1 0)
			)
		))

	; Integer Float Fraction Unknown_or_Invalid
	(define checkTypeOfNum (lambda (input_str num_of_e num_of_. num_of_/ hasDigit)
		(cond 
			; finish
			((null? input_str)
				(cond 
					; it is not num
					((eq hasDigit '0) 'Unknown_or_Invalid)
					;check fraction
					((eq num_of_/ '1) 
						(cond 
							((eq num_of_e '0)
								(cond 
									((eq num_of_. '0)
										'Fraction
										)
									('1 'Unknown_or_Invalid)
									)
								)
							('1 'Unknown_or_Invalid)
							)
						)
					; check integer
					((__AND__ (eq num_of_/ '0) (__AND__ (eq num_of_e '0) (eq num_of_. '0)))
						'Integer
						)
					((__OR__ (eq num_of_e 1) (eq num_of_. 1))
						'Float
						)
					('1  'Unknown_or_Invalid)
					)
				)
			((eq (car input_str) 'e)
				(checkTypeOfNum (cdr input_str) (+ num_of_e '1) num_of_. num_of_/ hasDigit)
				)
			((eq (car input_str) '.)
				(checkTypeOfNum (cdr input_str) num_of_e (+ num_of_. '1) num_of_/ hasDigit)
				)
			((eq (car input_str) '/)
				(checkTypeOfNum (cdr input_str) num_of_e num_of_. (+ num_of_/ '1) hasDigit)
				)
			((这个数字是整数 (car input_str)) 
				(checkTypeOfNum (cdr input_str) num_of_e num_of_. num_of_/ '1)
				)
			('1 'Unknown_or_Invalid)
			)
		))
	; 得到数据的类型
	(define typeOfNum (lambda (input_str)
		(cond 
			((eq (car input_str) '-)
				(checkTypeOfNum (cdr input_str) '0 '0 '0 '0)
				)
			('1 (checkTypeOfNum input_str '0 '0 '0 '0))
			)
		))

	;==== add ========
	(define _+_ (lambda (num1 num2)
		(cond 
			;是 fraction 直接进行计算
			((__OR__ 
				(eq 'Fraction (typeOfNum num1))
				(eq 'Fraction (typeOfNum num2))
				)
				(make_rat_string (add-rat (format_number num1) (format_number num2)))
				)
			('1 
				(+ num1 num2)
				)
			)
		))
	;==== substruction ===
	(define _-_ (lambda (num1 num2)
		(cond 
			;是 fraction 直接进行计算
			((__OR__ 
				(eq 'Fraction (typeOfNum num1))
				(eq 'Fraction (typeOfNum num2))
				)
				(make_rat_string (sub-rat (format_number num1) (format_number num2)))
				)
			('1 
				(- num1 num2)
				)
			)
		))	
	;==== Multplication ===
	(define _*_ (lambda (num1 num2)
		(cond 
			;是 fraction 直接进行计算
			((__OR__ 
				(eq 'Fraction (typeOfNum num1))
				(eq 'Fraction (typeOfNum num2))
				)
				(make_rat_string (mul-rat (format_number num1) (format_number num2)))
				)
			('1 
				(* num1 num2)
				)
			)
		))
	;==== Divition ===
	(define _/_ (lambda (num1 num2)
		(cond 
			;是 fraction 直接进行计算
			((__OR__ 
				(eq 'Fraction (typeOfNum num1))
				(eq 'Fraction (typeOfNum num2))
				)
				(make_rat_string (div-rat (format_number num1) (format_number num2)))
				)
			((__AND__
				(eq 'Integer (typeOfNum num1))
				(eq 'Integer (typeOfNum num2)))
				(make_rat_string (div-rat (format_number num1) (format_number num2)))
				)
			('1 
				(/ num1 num2)
				)
			)
		))		


	(display (_/_ 3 6))




;===========下面的代码不要了 ==============================


	; 表示数字的方式
	; 123 (3  2  1  ...)
	;      个 十  百 ...

	; 1 + 2 -> (0   3)
	; 3 + 7 -> (1   0) 
	;          进位 结果

	(define add_two_num (lambda (num1 num2)
		(cond 
			; num 0
			((eq num1 '0)
				(cond 
					((eq num2 '0)
						'(0 0)
						)
					((eq num2 '1)
						'(0 1)
						)
					((eq num2 '2)
						'(0 2)
						)
					((eq num2 '3)
						'(0 3)
						)
					((eq num2 '4)
						'(0 4)
						)
					((eq num2 '5)
						'(0 5)
						)
					((eq num2 '6)
						'(0 6)
						)
					((eq num2 '7)
						'(0 7)
						)
					((eq num2 '8)
						'(0 8)
						)
					((eq num2 '9)
						'(0 9)
						)
					)
				)
			; num 1
			((eq num1 '1)
				(cond 
					((eq num2 '0)
						'(0 1)
						)
					((eq num2 '1)
						'(0 2)
						)
					((eq num2 '2)
						'(0 3)
						)
					((eq num2 '3)
						'(0 4)
						)
					((eq num2 '4)
						'(0 5)
						)
					((eq num2 '5)
						'(0 6)
						)
					((eq num2 '6)
						'(0 7)
						)
					((eq num2 '7)
						'(0 8)
						)
					((eq num2 '8)
						'(0 9)
						)
					((eq num2 '9)
						'(1 0)
						)
					)
				)
						; num 2
			((eq num1 '2)
				(cond 
					((eq num2 '0)
						'(0 2)
						)
					((eq num2 '1)
						'(0 3)
						)
					((eq num2 '2)
						'(0 4)
						)
					((eq num2 '3)
						'(0 5)
						)
					((eq num2 '4)
						'(0 6)
						)
					((eq num2 '5)
						'(0 7)
						)
					((eq num2 '6)
						'(0 8)
						)
					((eq num2 '7)
						'(0 9)
						)
					((eq num2 '8)
						'(1 0)
						)
					((eq num2 '9)
						'(1 2)
						)
					)
				)
						; num 3
			((eq num1 '3)
				(cond 
					((eq num2 '0)
						'(0 3)
						)
					((eq num2 '1)
						'(0 4)
						)
					((eq num2 '2)
						'(0 5)
						)
					((eq num2 '3)
						'(0 6)
						)
					((eq num2 '4)
						'(0 7)
						)
					((eq num2 '5)
						'(0 8)
						)
					((eq num2 '6)
						'(0 9)
						)
					((eq num2 '7)
						'(1 0)
						)
					((eq num2 '8)
						'(1 1)
						)
					((eq num2 '9)
						'(1 2)
						)
					)
				)
						; num 4
			((eq num1 '4)
				(cond 
					((eq num2 '0)
						'(0 4)
						)
					((eq num2 '1)
						'(0 5)
						)
					((eq num2 '2)
						'(0 6)
						)
					((eq num2 '3)
						'(0 7)
						)
					((eq num2 '4)
						'(0 8)
						)
					((eq num2 '5)
						'(0 9)
						)
					((eq num2 '6)
						'(1 0)
						)
					((eq num2 '7)
						'(1 1)
						)
					((eq num2 '8)
						'(1 2)
						)
					((eq num2 '9)
						'(1 3)
						)
					)
				)
						; num 5
			((eq num1 '5)
				(cond 
					((eq num2 '0)
						'(0 5)
						)
					((eq num2 '1)
						'(0 6)
						)
					((eq num2 '2)
						'(0 7)
						)
					((eq num2 '3)
						'(0 8)
						)
					((eq num2 '4)
						'(0 9)
						)
					((eq num2 '5)
						'(1 0)
						)
					((eq num2 '6)
						'(1 1)
						)
					((eq num2 '7)
						'(1 2)
						)
					((eq num2 '8)
						'(1 3)
						)
					((eq num2 '9)
						'(1 4)
						)
					)
				)
						; num 6
			((eq num1 '6)
				(cond 
					((eq num2 '0)
						'(0 6)
						)
					((eq num2 '1)
						'(0 7)
						)
					((eq num2 '2)
						'(0 8)
						)
					((eq num2 '3)
						'(0 9)
						)
					((eq num2 '4)
						'(1 0)
						)
					((eq num2 '5)
						'(1 1)
						)
					((eq num2 '6)
						'(1 2)
						)
					((eq num2 '7)
						'(1 3)
						)
					((eq num2 '8)
						'(1 4)
						)
					((eq num2 '9)
						'(1 5)
						)
					)
				)
						; num 7
			((eq num1 '7)
				(cond 
					((eq num2 '0)
						'(0 7)
						)
					((eq num2 '1)
						'(0 8)
						)
					((eq num2 '2)
						'(0 9)
						)
					((eq num2 '3)
						'(1 0)
						)
					((eq num2 '4)
						'(1 1)
						)
					((eq num2 '5)
						'(1 2)
						)
					((eq num2 '6)
						'(1 3)
						)
					((eq num2 '7)
						'(1 4)
						)
					((eq num2 '8)
						'(1 5)
						)
					((eq num2 '9)
						'(1 6)
						)
					)
				)
						; num 8
			((eq num1 '8)
				(cond 
					((eq num2 '0)
						'(0 8)
						)
					((eq num2 '1)
						'(0 9)
						)
					((eq num2 '2)
						'(1 0)
						)
					((eq num2 '3)
						'(1 1)
						)
					((eq num2 '4)
						'(1 2)
						)
					((eq num2 '5)
						'(1 3)
						)
					((eq num2 '6)
						'(1 4)
						)
					((eq num2 '7)
						'(1 5)
						)
					((eq num2 '8)
						'(1 6)
						)
					((eq num2 '9)
						'(1 7)
						)
					)
				)
						; num 9
			((eq num1 '9)
				(cond 
					((eq num2 '0)
						'(0 9)
						)
					((eq num2 '1)
						'(1 0)
						)
					((eq num2 '2)
						'(1 1)
						)
					((eq num2 '3)
						'(1 2)
						)
					((eq num2 '4)
						'(1 3)
						)
					((eq num2 '5)
						'(1 4)
						)
					((eq num2 '6)
						'(1 5)
						)
					((eq num2 '7)
						'(1 6)
						)
					((eq num2 '8)
						'(1 7)
						)
					((eq num2 '9)
						'(1 8)
						)
					)
				)
			)
		))
	
	; 9 9 1
	; 先计算前两个数字
	; 9+9 -> (1 8)
	; (1 8)
	; ＝进位到结果＝
	; 进位 1 到 8
	; 8+1 -> (0 9)
	; ============
	; =进位计算====
	; (0 9)中的 0 加上 1
	; 			$
	; 进位的 1 加上 新进位的 0 -> 1
	; 1+0 -> (0 1) -> 1 as 最终进位
	; ============
	; 得到进位结果
	; output ->
	; 新进位 新结果
	; (1      9)
	;

	; (1 9) 2 -> (2 1)
	(define 进位计算过程 (lambda (计算前两个数字的结果 进位)
		; 9+2 -> (1 1) 为结果
		; （1 9） 中的 1 为进位
		(更新进位 (add_two_num (cadr 计算前两个数字的结果) 进位) (car 计算前两个数字的结果))
		))

	(define 更新进位 (lambda (结果 进位)
		(cons (cadr (add_two_num (car 结果) 进位))  (cdr 结果))
		))

	(define add_three_nums (lambda (num1 num2 num3)
		(进位计算过程 (add_two_num num1 num2) num3)
		))

	;========== 计算两个数字 ======================================
	; 只能计算正整数
	; this function can be used to calcuate two positive intergers
	; 12 + 34 format as
	; (2 1) (4 3) 
	(define 加上两个数字以及进位数字_iter (lambda (数字1 数字2 进位)
		(cond 
			((null? 数字1)
				(cond 
					 ;计算完成 
					((null? 数字2)
						'())
					; 位数不一样
					('1 
						(辅助_加上两个数字以及进位数字_iter的函数 (add_three_nums '0 (car 数字2) 进位) 数字1 (cdr 数字2))	
						)
					)
				)
			((null? 数字2)
				(cond 
					 ;计算完成 
					((null? 数字1)
						'())
					; 位数不一样
					('1 
						(辅助_加上两个数字以及进位数字_iter的函数 (add_three_nums (car 数字1) '0 进位) (cdr 数字1) 数字2)	
						)
					)
				)
			('1
				(辅助_加上两个数字以及进位数字_iter的函数 (add_three_nums (car 数字1) (car 数字2) 进位) (cdr 数字1) (cdr 数字2))	
				)
			)
		))
	(define 辅助_加上两个数字以及进位数字_iter的函数 (lambda (三个数字的计算结果 剩余数字1 剩余数字2)
		(cons 
			(cadr 三个数字的计算结果) 
			(加上两个数字以及进位数字_iter 剩余数字1 剩余数字2 (car 三个数字的计算结果) ) )
		))

	(define 计算两个数字 (lambda (数字1 数字2)
		(加上两个数字以及进位数字_iter 数字1 数字2 '0)
		))

	;============= 补全位数================
	; 小数点前的补全
	; eg:
	;	210 + 15
	;   2 1 0
	; + 0 1 5
	; ------------
	; ((0 2 1) (5 1 0))
	;

	; (得到... '(1 2 3)) -> (0 0 0)
	(define 得到全是0的list (lambda (剩余的参考list)
		(cond 
			((null? 剩余的参考list) '())
			('1 (cons '0 (得到全是0的list (cdr 剩余的参考list))))
			)
		))
	(define 补全位数 (lambda (要被补全的 剩余的参考list)
		(append 要被补全的 (得到全是0的list 剩余的参考list))
		))
	(define 小数点前补全位数_iter (lambda (数字1 数字2 数字1_备份 数字2_备份)
		(cond 
			((null? 数字1)
				(cond 
					((null? 数字2)
						(cons 数字1_备份 (cons 数字2_备份 '()))
						)
					('1 (cons (补全位数 数字1_备份 数字2) (cons 数字2_备份 '()) ))
					)
				)
			((null? 数字2)
				(cond 
					((null? 数字1)
						(cons 数字1 (cons 数字2_备份 '()))
						)
					('1 (cons 数字1_备份 (cons (补全位数 数字2_备份 数字1) '()) ))
					)
				)
			('1 (小数点前补全位数_iter (cdr 数字1) (cdr 数字2) 数字1_备份 数字2_备份))
			)
		))
	(define 小数点前补全位数 (lambda (数字1 数字2)
		(小数点前补全位数_iter 数字1 数字2 数字1 数字2)
		))

	;===== 小数点后补全位数 ========
	; .123 + .1
	; 	.1 2 3
	; +	.1 0 0
	; ((3 2 1) (0 0 1))
	;=============================

	(define 补全位数_小数点后 (lambda (要被补全的 剩余的参考list)
		(append (得到全是0的list 剩余的参考list) 要被补全的)
		))
	(define 小数点后补全位数_iter (lambda (数字1 数字2 数字1_备份 数字2_备份)
		(cond 
			((null? 数字1)
				(cond 
					((null? 数字2)
						(cons 数字1_备份 (cons 数字2_备份 '()))
						)
					('1 (cons (补全位数_小数点后 数字1_备份 数字2) (cons 数字2_备份 '()) ))
					)
				)
			((null? 数字2)
				(cond 
					((null? 数字1)
						(cons 数字1 (cons 数字2_备份 '()))
						)
					('1 (cons 数字1_备份 (cons (补全位数_小数点后 数字2_备份 数字1) '()) ))
					)
				)
			('1 (小数点后补全位数_iter (cdr 数字1) (cdr 数字2) 数字1_备份 数字2_备份))
			)
		))
	(define 小数点后补全位数 (lambda (数字1 数字2)
		(小数点后补全位数_iter 数字1 数字2 数字1 数字2)
		))

	; ======== 格式化 数字 (不是 分数)
	; 12 -> ( (2 1)     ( )      )
	;		小数点前   小数点后
	; 13.04 -> ((3 1)    (4 0)     )
	;          小数点前   小数点后
	;
	;

	(define 格式化没有.的数字_iter (lambda (数字 结果)
		(cond 
			((null? 数字) 结果)
			('1 (格式化没有.的数字_iter (cdr 数字) (cons (car 数字) 结果)))
			)
		))
	; 这个函数将会将 123 －》 （3 2 1）
	(define 格式化没有.的数字 (lambda (数字)
		(格式化没有.的数字_iter 数字 '())
		))


	(define 格式化数字_iter (lambda (数字 小数点前部分 小数点后部分)
		(cond 
			((null? 数字)
				(cons 小数点前部分 (cons 小数点后部分 '()))
				)
			; 发现小数点
			((eq (car 数字) '.)
				(cons 
					小数点前部分 
					(cons 
						(格式化没有.的数字 (cdr 数字)) 
						'())
					)
				)
			; 未发现小数点的
			('1 (格式化数字_iter (cdr 数字) (cons (car 数字) 小数点前部分) 小数点后部分))

			)
		))
	; 123.12 -> ((3 2 1) (2 1))
	(define 格式化数字 (lambda (数字)
		(格式化数字_iter 数字 '() '())
		))

	; ====== 加法_已格式化的数字
	; 123.12 + 34
	; ((3 2 1) (2 1)) + ((4 3) ())
	(define 加法_已格式化的数字 (lambda (数字1 数字2)

		))


	;(display (格式化数字 '1234.56345))
	;(display (计算两个数字 '(1 0 1) '(9 1) ))
	;(display (计算两个数字 '(1 0 1) '(9 1) ))
	;(display (小数点后补全位数 '(2 1 3) '(0 0 1 3)))
	;(display (add_three_nums '9 '9 '9))
	;(display (assoc 'a '((a (a b c)))))
	;(display (toy '(apply cdr '(a b c)) '((a 1) (b (a b c))) ""))

)













