(begin
	;==============================================
	;==============================================
	;==============================================
	;===== Begin to construct Toy Language ========
	;==============================================
	;
	;
	;
	;	 I will only write this in 
	;	'quote car cdr cons cond eq atom' 
	;	====
	;   and one 'define' function
	(define cadr (lambda (_list_)
		(car (cdr _list_))
		))
	(define caar (lambda (_list_)
		(car (car _list_))
		))
	(define cdar (lambda (_list_)
		(cdr (car _list_))
		))
	(define cadar (lambda (_list_)
		(car (cdr (car _list_)))
		))
	(define caddr (lambda (_list_)
		(car (cdr (cdr _list_)))
		))
	(define caddar (lambda (_list_)
		(car (cdr (cdr (car _list_))))
		))

	(define null? (lambda (x)
		(eq x '())
		))
	; '(a b) '(c d) -> (a b c d)
	(define append (lambda (x y)
		(cond 
			((null? x) y)
			(1 (cons (car x) (append (cdr x) y)))
			)
		))
	; '(a b) '(3 4) -> ((a 3) (b 4))
	(define pair (lambda (x y)
		(cond
			((and (null? x) (null? y) )  '() )
			(1 (cons (cons (car x) (cons (car y) '())) (pair (cdr x) (cdr y))))
			)
		))
	; get value according to key
	; (assoc 'x '((x  a) (y  b) )) -> a
	(define assoc (lambda (x y)
		(cond 
			; Error can not find value
			((null? y) 
					(display 'Error_Cannot_Find)
				)
			((eq (caar y) x) (cadar y))
			(1 (assoc x (cdr y)) )
			)
		))

	; Toy Language iteration
	(define toy_language (lambda (trees env module_name)
		(cond
			; finish toy_language
			((null? trees) env)
			; iteration
			(1
				(toy_language 
					; next tree
					(cdr trees)
					; update environment
					(cdar (toy (car trees) env module_name))
					; module_name
					module_name)
				)
			)
		))

	; [value , env]
	(define cons_env (lambda (value env)
		(cons value (cons env '()))
		))

	; =========================
	; for define function
	;check whether var existed
	(define var_existed(lambda (var_name env)
		(cond 
			((null? env) 0)
			((eq var_name (caar env)) 1)
			(1 (var_existed var_name (cdr env)))
			)
		))
	; update var_name
	; add module_name
	(define var_name_update (lambda (var_name module_name)
		(cond 
			((eq module_name "") var_name)
			(1 (cons (module_name '.) var_name))
			)
		))
	; deal with return object
	; where return object is toy
	; return_obj[0] = var_value
	; return_obj[1] = new_env

	(define deal_with_return_obj (lambda (return_obj var_name)
		(cons 
			; add var_value
			(car return_obj)
		(cons 
		(cons 
			; [var_name var_value]
			(cons var_name (cons (car return_obj) '()))
			(cadr return_obj)
			)  '())
			)
		))

	;define function procedure
	(define define_procedure (lambda (updated_var_name uncalculated_var_value env module_name)
		(cond 
			((var_existed updated_var_name env)
				(display (cons (cons "Error " updated_var_name) " Has already be defined") )
				)
			(1 (deal_with_return_obj (toy uncalculated_var_value env module_name) updated_var_name))
			)
		))

	;=================== END define function procedure ==========
	;============================================================

	;========= set! function procedure ==========

	; return new environment
	(define set_index (lambda (var_name var_value env)
		(cond
			((null? env) 
				((lambda (a b) b) 
					(display (cons (cons "Error...In function set! " var_name) " does not exist")) '()
					)
				)
			; find var
			((eq var_name (caar env))
				(cons 
					; (var_name var_value)
					(cons 
						var_name
						(cons var_value '())
						)
					; rest of env
					(cdr env))
				)
			(1 (cons (car env) (set_index var_name var_value (cdr env))))
			)
		))
	
	(define set!_procedure (lambda (var_name return_obj)
		;(var_value new_env)
		(cons (car return_obj) (cons (set_index var_name (car return_obj) (cadr return_obj)) '()))
		))


	;========= End set! function procedure ======

	;========= let function procedure ===========
	;============================================
	(define let_procedure (lambda (return_obj env)
		1
		))
	;=================== END let function procedure =============
	;============================================================

	; Toy Language
	; (toy 'x  '((x . a)) ) -> x
	; expr is the expression that need to be evaluated
	; env is the environment
	(define toy (lambda (expr env module_name)
		(cond
			; it is number
			((number? expr) (cons_env expr env))
			; it is atom
			;				[value,env]
			((atom? expr) (cons (assoc expr env) (cons env '())) )
			((atom? (car expr))
				(cond
					; seven primitive functions
					; (quote x) -> x
					;						 [value,env]
					((eq (car expr) 'quote) (cons (cadr expr) (cons env '()) ))
					; (atom? 'x) -> 1
					((eq (car expr) 'atom?) 
						(cons_env (atom? (car (toy (cadr expr) env module_name))) env)
						)
					; (eq 'x 'x) -> 1
					((eq (car expr) 'eq)  
						(cons_env
							(eq 
								(car (toy (cadr expr) env module_name))
								(car (toy (caddr expr) env module_name))
								)
							env
						)
						)
					; (car '(a b))->a
					((eq (car expr) 'car) 
						(cons_env 
							(car (car (toy (cadr expr) env module_name)))
							env
						)

						)
					; (cdr '(a b)) -> (b)
					((eq (car expr) 'cdr) 
						(cons_env
							(cdr (car (toy (cadr expr) env module_name) ) )
							env
							)
						)
					; (cons 'a '(a) ) -> (a a)
					((eq (car expr) 'cons)
						(cons_env
							(cons 
								(car (toy (car (cdr expr)) env module_name))
								(car (toy (car (cdr (cdr expr))) env module_name))
								)
							env
							)
						)
					; (cond (judge1 stm1) (judge2 stm2) ) 
					((eq (car expr) 'cond) (eval_cond (cdr expr) env module_name))

					; builtin functions
					; define function
					((eq (car expr) 'define)
						(define_procedure 
							(var_name_update (cadr expr) module_name)
							(caddr expr)
							env 
							module_name
							)
						)
					; set! function
					((eq (car expr) 'set!) 
						(set!_procedure
							(cadr expr)
							(toy (caddr expr) env module_name)
							)
						)
					;=== my idea ====
					((eq (car expr) 'lambda)
						expr
						)
					; (begin stm1 stm2)
					((eq (car expr) 'begin)
						(eval_begin (cdr expr) env)
						)
					; (let ((var value) (var value) ... ) stm )
					((eq (car expr) 'let)
						(toy (caddr expr) (eval_let (cadr expr) env))
						)
					; (procesdure argv...)
					(1 
						(toy (cons (assoc (car expr) env) (cdr expr)) env)
						)
					)
				)
			; label function
			((eq (caar expr) 'label)
				(toy (cons (caddar expr) (cdr expr))
					(cons (list (cadar expr) (car expr)) env )
					)
				)
			; lambda function
			((eq (caar expr) 'lambda)
				(toy (caddar expr)
					(append (pair (cadar expr) (evlis (cdr expr) env)) env)
					)
				)
			)
		))


	; return new env
	; expr -> ((a 12)(b 13)) 
	; env -> ((c 14))
	; return ((a 12)(b 13)(c 14))
	(define eval_let (lambda (expr env)
		(cond 
			((eq expr '()) env)
			(1 
				(cons    
					(cons (caar expr) (cons (toy (cadar expr) env) '()))
					(eval_let (cdr expr) env))
				)
			)
		))

	; eval cond function
	(define eval_cond (lambda (expr env module_name)
		(cond 
			((car (toy (caar expr) env module_name))
			 (toy (cadar expr) env module_name)
				)
			(1 (eval_cond (cdr expr) env module_name))
			)
		))

	; compute function params
	(define evlis (lambda (m a)
		(cond 
			((null? m) '())
			(1 (cons (toy (car m) a) (evlis (cdr m) a)))
			)
		))
	; eval begin function
	; stms -> (stm1 stm2 stm3)
	(define eval_begin (lambda (stms env)
		(cond 
			((null? stms)(display "Error...begin function invalid parameters"))
			((null? (cdr stms))  (toy (car stms) env))
			(1
				(cond 
					; it is atom
					; so not calculated
					((atom? (car stms)) (eval_begin (cdr stms) env))
					(1
						(cond
							; define
							; (define x 12)
							; (define y 13) ... something like that
							((eq (caar stms) 'define)
								(eval_begin (cdr stms) (cons (cons (cadar stms) (cons (toy (caddar stms) env) '())) env))
								)
							; change existed value
							((eq (caar stms) 'set!)
								(eval_begin (cdr stms) (set!_env (cadar stms) (toy (caddar stms) env) env) )
								)
							)
						)
					)
				)
			; define can only be used inside begin
			)
		))

	; var_name -> x
	; var_value -> 12
	; env -> ((y 12) (x 1))
	; return ((y 12) (x 12))
	(define set!_env (lambda (var_name var_value env)
		(cond
			((null? env) "Error...set!_env function error")
			((eq (caar env) var_name)
				(cons (cons var_name (cons var_value '()))  (cdr env))
				)
			(1 
				(cons (car env) (set!_env var_name var_value (cdr env)))
				)
			)
		))

	(display (assoc 'a '((a (a b c)))))
	;(display (toy 'a '((a (a b c))) ""))
	(display (toy '(set! a 'b) '( (a (a b c)) (b (a b c))  ) ""))

)













