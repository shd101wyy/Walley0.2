(stms
	;This program is written by Yiyi Wang to test Toy Language"
	;I recommended u to start the program by stating (stms ) function"
	(define display print)
	(define begin stms)
	;# function list"
    ;# (list 1 2 3) ---> (1 2 3)"
    ;Has bug when"
    ; (define x 12) (define x (list 1 x))"
	(define list (lambda (. args) 
		(if (null? args) '() (cons (car args) (apply list (cdr args))))
		)
	)
	
	;Arithmetic Operation"
	;Now only support number, exclude fraction, real, complex"
	(define + (lambda (. args)
		(if (null? args) 0 (__ADD__ (car args) (apply + (cdr args)))
			)
		)
	)
	(define - (lambda (. args)
		(if (null? args) 0 (__MINUS__ (car args) (apply - (cdr args)))
			)
		)
	)

	(define * (lambda (. args)
		(if (null? args) 1 (__MULT__ (car args) (apply * (cdr args)))
			)
		)
	)
	(define / (lambda (. args)
		(if (null? args) 1 (__DIV__ (car args) (apply / (cdr args)))
			)
		)
	)

	(define null? (lambda (a)(if (eq a '()) 1 0)))
	(define empty? null?)

	;Condition judge > < =(==) != >= <=" 
	(define = (lambda (. args)
		(cond ( (__EQUAL__ 2 (len args)) (__EQUAL__ (car args) (car (cdr args))) ) (1 (__AND__ (__EQUAL__ (car args) (car (cdr args))) (apply = (cdr args))) )
			)
		)
	)
	(define == =)
	(define < (lambda (. args)
		(if (= 2 (len args)) (__LT__ (car args) (car (cdr args))) (__AND__ (__LT__ (car args) (car (cdr args))) (apply < (cdr args)) )
			)
		)
	)	
	(define <= (lambda (. args)
		(if (= 2 (len args)) (__OR__ (apply = args) (apply < args)) (__AND__ (__OR__ (apply = (list (car args) (car (cdr args)))) (apply < (list (car args) (car (cdr args))))) (apply <= (cdr args)) )
			)
		)
	)


	;greater"
	(define __GT__ (lambda (a b)(
		if (apply <= (list a b)) 0 1
			)
		)
	)

	(define > (lambda (. args) (
		if (= 2 (len args)) (__GT__ (car args) (car (cdr args))) (__AND__ (__GT__ (car args) (car (cdr args))) (apply > (cdr args)) )
			)
		)
	)

	(define >= (lambda (. args)(
		if (= 2 (len args)) (or (apply = args) (apply > args)) (__AND__ (__OR__ (apply = (list (car args) (car (cdr args)) ) ) (apply > (list (car args) (car (cdr args))))) (apply >= (cdr args)) )
			)
		)
	)

	(define != (lambda (. args)
		(if (= 2 (len args)) (not (= (car args) (car (cdr args)))) (__AND__ (not (= (car args) (car (cdr args)))) (apply != (cdr args)) )
			)
		)
	)

	(define __AND__ (lambda (a b)
		(if a 
			(if b 
				1
				0
				)
			0
			)
		)
	)

	(define __OR__ (lambda (a b)
		(if a 
			1
			(if b
				1
				0
				)

			)
		)
		
	)
	(define and (lambda (. args) (
		if (null? args)
			1
			(__AND__ (car args) (apply and (cdr args)))
			)
		)
	)

	(define or (lambda (. args) (
		if (null? args)
			0
			(__OR__ (car args) (apply or (cdr args)))
			)
		)
	)

	(define not (lambda (a) 
			(if a 0 1)
		)
	)

	(define nil 0)
	;function while"
    ;(while (< i 10) (= i (+ i 1)))"
	(define while (lambda (&judge &stm) (
		cond (judge (stms stm (while judge stm))) (1 nil)
			)
		)
	)


	;function if"
    ;(if [judge] [run if pass] [run if not pass])"
	(define if (lambda (&condition &stm1 &stm2) (cond (condition stm1) (1 stm2))))

	;One bug here"
	;(print (<= 4 3 4))"

	;(remainder 3 4) ->3"
	(define remainder (lambda (a b) 
			(
				if (< a b) a (remainder (- a b) b)
			)
		)
	)
	(define % remainder)


	;list? function will return 1 if it is list"
	(define list? (lambda (a)
			(if (atom? a) 0 1)
		)
	)

	;======================================================================"



	(define +1 (lambda (x) (+ x 1)))

	;======================================================================"
	;list "
		;get the last element of __list__"
		(define last (lambda (__list__) 
			(if (null? __list__ ) (print "Error...Cannot get last atom of empty list")
				(if (null? (cdr __list__ )) 
						(car __list__ )  
						(last (cdr __list__ ))
					)
				)
			)
		)
		;list-length"
		;which can be used to get the length of list"
		(define list-length (lambda (_list_)
			(define list-length-iter (lambda (_list_ count) 
				(if (null? _list_) count (list-length-iter (cdr _list_) (+ count 1))) 
				))
			(if (list? _list_)
				(list-length-iter _list_ 0)
				(print "Error...Function list-length can not be used to get length of non-list type value")
			)
		  )
		)
		(define len list-length)

		;test list-length"
		;(print (list-length '(1 2 3)))"
		;(print (list-length 12))"

		;====================================="
		;list-get"
		;get list at index"
		(define list-get (lambda (_list_ index)
				(if (>= index (list-length _list_))
					(print "Error...Index out of range")
					(if (= index 0)
						(car _list_)
						(list-get (cdr _list_) (- index 1))
					)
				)
			)
		)
		;test list-get"
		;(print (list-get '(12 2 14) 2))"
	;====================="
	;Function: list-append"
	;(list-append '() 12) -> (12)"
	;(list-append '(1 2) '(14 15)) -> (1 2 (14 15))"
	(define list-append (lambda (a b)
			(stms
				(define output (cons b '()))
				(define i (- (list-length a) 1))
				(while (>= i 0)
					(stms
						(set! output (cons (list-get a i) output))
						(set! i (- i 1))
					)
				)
				output
			)
		)
	)
	;(print (list-append '(1 2) '(14 15) ))"

	;==============="
	;Function: Range"
	;(range 10)"
	;(range 0 10)"
	;(range 0 10 1)"
	(define range (lambda (arg0 . args) (stms
				(cond 
					((= args '())
						(stms 
							(define begin 0)
							(define end arg0)
							(define interval 1)
							(define output '())
						)
					)
					((= 1 (list-length args))
						(stms 
							(define begin arg0)
							(define end (car args))
							(define interval 1)
							(define output '())
						)
					)
					(1 
						(stms 
							(define begin arg0)
							(define end (car args))
							(define interval (car (cdr args)))
							(define output '())

						)
					) 

				)
				(if (> interval 0 ) 
					(while (< begin end) (stms (set! output (list-append output begin)) (set! begin (+ begin interval))))
					(while (> begin end) (stms (set! output (list-append output begin)) (set! begin (+ begin interval))))
				)
				output
			)
		)
	)
	;Test"
	;(print (range 2 100 1))"


	;==============================================
	;==============================================
	; SICP
	; Netween's method for SQRT
	(define abs (lambda (a) 
		(cond 
			((< a 0) (- 0 a)) 
			(1 a)
			)
		)
	)
	; test absolute
	;(display (abs -12))

	; sqrt
	; 允许的误差数
	; sqrt
	; 允许的误差数
	(define __SQRT_ACCURATE__ 0.001)
	(define sqrt (lambda (x)
		(define sqrt-iter (lambda (guess)
	  		(cond ((good-enough? guess) guess)
	      		  (1 (sqrt-iter (improve guess)))
				)
	  		)
		)
		(define improve (lambda (guess)
	  		(average guess (/ x guess)))		
		)
		(define average (lambda (x y)
	  		(/ (+ x y) 2)))
		(define good-enough? (lambda (guess)
	  		(< (abs (- (* guess guess) x)) __SQRT_ACCURATE__)))
  		(sqrt-iter __SQRT_ACCURATE__)))



	; factorial
	(define factorial (lambda (x)
		(define factorial_iter (lambda (outcome count)
		 	(if (== count 1) outcome (factorial_iter (* outcome (- count 1)) (- count 1)))
			;(cond ((== count 1) outcome) (1 (factorial_iter (* outcome (- count 1)) (- count 1))))
			)
		)
		(factorial_iter x x)
		))
	;(display (factorial 6))

	; expt
	; only support 2^3 like 3 must be > 0
	(define expt (lambda (a b)
		(define expt_inter (lambda (result count)
			(if (== count 1) result (expt_inter (* result a) (- count 1)))
			) 
		)
		(if (== b 0) 1 (expt_inter a b)))
	)
	;(display (expt 3 2))
	(define ^ expt)
	(define ** expt)

	; sicp Exercise 1.15
	; sin
	; 允许的sin误差范围
	(define __SIN_ACCURACY__ 0.01)
	(define cube (lambda (x) (* x x x)))
	(define p (lambda (x) (- (* 3 x) (* 4 (cube x)))))
	(define sine (lambda (angle)
		(if (not (> (abs angle) __SIN_ACCURACY__))
	        angle
			(p (sine (/ angle 3.0))))))
	; (display (sine 12))
	(define sin sine)

	(define pi 3.141592653589793)
	;		sin  cos
	;	 tan		 cot
	; 		sec   csc
	; cos(x) = sin(x+pi/2)
	(define cos (lambda (x) (sin (+ x (/ pi 2)))))
	(define sec (lambda (x) (/ 1 (cos x))))
	(define csc (lambda (x) (/ 1 (sin x))))
	(define tan (lambda (x) (/ (sin x) (cos x))))
	(define cot (lambda (x) (/ 1 (tan x))))
	; I didnt use Taylor Series when calculating sin cos tan cot sec csc

	; check whether number is even
	(define even? (lambda (x) (if (= (% x 2) 0) 1 0) ))
	(define odd? (lambda (x) (if (even? x) 0 1) ))













)